<?php

declare(strict_types=1);

namespace event4u\DataHelpers\SimpleDTO;

use DateTimeInterface;
use event4u\DataHelpers\SimpleDTO\Attributes\Computed;
use event4u\DataHelpers\SimpleDTO\Attributes\DataCollectionOf;
use event4u\DataHelpers\SimpleDTO\Attributes\Lazy;
use ReflectionClass;
use ReflectionNamedType;
use ReflectionProperty;
use ReflectionUnionType;
use Throwable;

/**
 * Generates TypeScript interfaces from SimpleDTOs.
 *
 * This class analyzes DTO classes and generates corresponding TypeScript
 * interface definitions, including support for:
 * - Basic types (string, number, boolean, etc.)
 * - Nullable types
 * - Arrays
 * - Nested DTOs
 * - Enums
 * - Union types
 * - Computed properties
 * - Lazy properties (marked as optional)
 *
 * @example
 * ```php
 * $generator = new TypeScriptGenerator();
 * $typescript = $generator->generate([UserDTO::class, ProductDTO::class]);
 * file_put_contents('types.ts', $typescript);
 * ```
 */
class TypeScriptGenerator
{
    /**
     * Cache for already processed DTOs to avoid duplicates.
     *
     * @var array<string, bool>
     */
    private array $processedDtos = [];

    /**
     * List of DTOs to process (queue).
     *
     * @var array<string>
     */
    private array $dtoQueue = [];

    /**
     * Cache for casts() method results.
     *
     * @var array<string, array<string, string>>
     */
    private array $castsCache = [];

    /**
     * Generate TypeScript interfaces for given DTO classes.
     *
     * @param array<class-string> $dtoClasses
     * @param array{exportType?: string, includeComments?: bool, sortProperties?: bool} $options
     */
    public function generate(array $dtoClasses, array $options = []): string
    {
        $exportType = $options['exportType'] ?? 'export';
        $includeComments = $options['includeComments'] ?? true;
        $sortProperties = $options['sortProperties'] ?? false;

        $this->processedDtos = [];
        $this->dtoQueue = $dtoClasses;

        $interfaces = [];

        // Process all DTOs in queue (including nested DTOs discovered during processing)
        while ([] !== $this->dtoQueue) {
            $dtoClass = array_shift($this->dtoQueue);

            if (isset($this->processedDtos[$dtoClass])) {
                continue;
            }

            $this->processedDtos[$dtoClass] = true;

            $interfaces[] = $this->generateInterface($dtoClass, $exportType, $includeComments, $sortProperties);
        }

        // Add header
        $header = $this->generateHeader();

        return $header . "\n" . implode("\n\n", $interfaces) . "\n";
    }

    /** Generate header comment. */
    private function generateHeader(): string
    {
        $date = date('Y-m-d H:i:s');

        return <<<TS
/**
 * Auto-generated TypeScript interfaces from SimpleDTOs
 * Generated at: {$date}
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * This file is auto-generated. Any manual changes will be overwritten.
 */

TS;
    }

    /**
     * Generate TypeScript interface for a single DTO class.
     *
     * @param class-string $dtoClass
     */
    private function generateInterface(
        string $dtoClass,
        string $exportType,
        bool $includeComments,
        bool $sortProperties
    ): string {
        $reflection = new ReflectionClass($dtoClass);
        $interfaceName = $reflection->getShortName();

        $lines = [];

        // Add comment
        if ($includeComments) {
            $lines[] = "/**";
            $lines[] = ' * ' . $interfaceName;
            $lines[] = " * ";
            $lines[] = ' * Generated from: ' . $dtoClass;
            $lines[] = " */";
        }

        // Start interface
        $lines[] = sprintf('%s interface %s {', $exportType, $interfaceName);

        // Get properties
        $properties = $this->getProperties($reflection);

        // Sort properties if requested
        if ($sortProperties) {
            ksort($properties);
        }

        // Add properties
        foreach ($properties as $propertyName => $propertyType) {
            $lines[] = sprintf('  %s: %s;', $propertyName, $propertyType);
        }

        // End interface
        $lines[] = "}";

        return implode("\n", $lines);
    }

    /**
     * Get all properties for a DTO class.
     *
     * @param ReflectionClass<object> $reflection
     * @return array<string, string> Property name => TypeScript type
     */
    private function getProperties(ReflectionClass $reflection): array
    {
        $properties = [];

        // Get constructor properties
        $constructor = $reflection->getConstructor();
        if (null !== $constructor) {
            foreach ($constructor->getParameters() as $parameter) {
                $propertyName = $parameter->getName();
                $property = $reflection->getProperty($propertyName);

                // Check if property is lazy (should be optional)
                $isLazy = $this->isLazyProperty($property);

                $tsType = $this->getTypeScriptType($property);

                // Make lazy properties optional
                if ($isLazy) {
                    $propertyName .= '?';
                }

                $properties[$propertyName] = $tsType;
            }
        }

        // Get computed properties
        $computedProperties = $this->getComputedProperties($reflection);
        foreach ($computedProperties as $name => $type) {
            $properties[$name] = $type;
        }

        return $properties;
    }

    /** Check if property is lazy. */
    private function isLazyProperty(ReflectionProperty $property): bool
    {
        $lazyAttrs = $property->getAttributes(Lazy::class);

        return [] !== $lazyAttrs;
    }

    /**
     * Get computed properties from DTO class.
     *
     * @param ReflectionClass<object> $reflection
     * @return array<string, string> Property name => TypeScript type
     */
    private function getComputedProperties(ReflectionClass $reflection): array
    {
        $properties = [];

        foreach ($reflection->getMethods() as $method) {
            $computedAttrs = $method->getAttributes(Computed::class);
            if (empty($computedAttrs)) {
                continue;
            }

            /** @var Computed $computed */
            $computed = $computedAttrs[0]->newInstance();

            // Use custom name if provided
            $propertyName = $computed->name ?? $method->getName();

            // Make lazy computed properties optional
            if ($computed->lazy) {
                $propertyName .= '?';
            }

            // Get return type
            $returnType = $method->getReturnType();
            $tsType = $this->convertPhpTypeToTypeScript($returnType);

            $properties[$propertyName] = $tsType;
        }

        return $properties;
    }

    /** Get TypeScript type for a property. */
    private function getTypeScriptType(ReflectionProperty $property): string
    {
        $type = $property->getType();
        $propertyName = $property->getName();
        $className = $property->getDeclaringClass()->getName();

        // Check for cast in casts() method
        $casts = $this->getCastsForClass($className);
        if (isset($casts[$propertyName])) {
            $castType = $this->getCastTypeScriptType($casts[$propertyName]);
            if (null !== $castType) {
                return $castType;
            }
        }

        // Check for DataCollectionOf attribute
        $collectionAttrs = $property->getAttributes(DataCollectionOf::class);
        if ([] !== $collectionAttrs) {
            /** @var DataCollectionOf $collection */
            $collection = $collectionAttrs[0]->newInstance();
            $dtoClass = $collection->dtoClass;

            // Add to queue for processing
            if (!isset($this->processedDtos[$dtoClass])) {
                $this->dtoQueue[] = $dtoClass;
            }

            $dtoName = (new ReflectionClass($dtoClass))->getShortName();

            return $dtoName . '[]';
        }

        return $this->convertPhpTypeToTypeScript($type);
    }

    /**
     * Get casts for a DTO class.
     *
     * @param class-string $className
     * @return array<string, string>
     */
    private function getCastsForClass(string $className): array
    {
        if (isset($this->castsCache[$className])) {
            return $this->castsCache[$className];
        }

        try {
            $reflection = new ReflectionClass($className);
            $method = $reflection->getMethod('casts');

            // Create a temporary instance to call the method
            $instance = $reflection->newInstanceWithoutConstructor();
            $casts = $method->invoke($instance);

            if (!is_array($casts)) {
                $casts = [];
            }

            /** @var array<string, string> $casts */
            $this->castsCache[$className] = $casts;

            return $this->castsCache[$className];
        } catch (Throwable) {
            $this->castsCache[$className] = [];

            return [];
        }
    }

    /** Get TypeScript type from Cast attribute. */
    private function getCastTypeScriptType(string $cast): ?string
    {
        // Handle cast with parameters (e.g., 'decimal:2', 'datetime:Y-m-d')
        $castType = explode(':', $cast)[0];

        return match ($castType) {
            'boolean', 'bool' => 'boolean',
            'integer', 'int' => 'number',
            'float', 'double' => 'number',
            'decimal' => 'string', // Decimals are strings in TypeScript
            'string' => 'string',
            'array', 'json' => 'any[]',
            'datetime', 'date' => 'string', // ISO 8601 string
            'collection' => 'any[]',
            default => null,
        };
    }

    /** Convert PHP type to TypeScript type. */
    private function convertPhpTypeToTypeScript(mixed $type): string
    {
        if (null === $type) {
            return 'any';
        }

        if ($type instanceof ReflectionNamedType) {
            return $this->convertNamedType($type);
        }

        if ($type instanceof ReflectionUnionType) {
            return $this->convertUnionType($type);
        }

        return 'any';
    }

    /** Convert named type to TypeScript. */
    private function convertNamedType(ReflectionNamedType $type): string
    {
        $typeName = $type->getName();
        $isNullable = $type->allowsNull();

        $tsType = match ($typeName) {
            'string' => 'string',
            'int', 'integer', 'float', 'double' => 'number',
            'bool', 'boolean' => 'boolean',
            'array' => 'any[]',
            'mixed' => 'any',
            'void' => 'void',
            'null' => 'null',
            default => $this->handleComplexType($typeName),
        };

        // Add null if nullable
        if ($isNullable && 'any' !== $tsType && 'null' !== $tsType) {
            return $tsType . ' | null';
        }

        return $tsType;
    }

    /** Handle complex types (DTOs, DateTime, etc.). */
    private function handleComplexType(string $typeName): string
    {
        // Check if it's a DateTime type
        if (is_subclass_of($typeName, DateTimeInterface::class)) {
            return 'string'; // ISO 8601 string
        }

        // Check if it's an enum
        if (enum_exists($typeName)) {
            return $this->convertEnumType($typeName);
        }

        // Check if it's a DTO
        if (class_exists($typeName)) {
            try {
                $reflection = new ReflectionClass($typeName);

                // Check if it uses SimpleDTOTrait
                $traits = $this->getAllTraits($reflection);
                if (in_array(SimpleDTOTrait::class, $traits, true)) {
                    // Add to queue for processing
                    if (!isset($this->processedDtos[$typeName])) {
                        $this->dtoQueue[] = $typeName;
                    }

                    return $reflection->getShortName();
                }
            } catch (Throwable) {
                return 'any';
            }
        }

        return 'any';
    }

    /**
     * Get all traits used by a class (including parent classes).
     *
     * @param ReflectionClass<object> $reflection
     * @return array<string>
     */
    private function getAllTraits(ReflectionClass $reflection): array
    {
        $traits = [];

        // Get traits from current class
        $traits = array_merge($traits, $reflection->getTraitNames());

        // Get traits from parent classes
        $parent = $reflection->getParentClass();
        while (false !== $parent) {
            $traits = array_merge($traits, $parent->getTraitNames());
            $parent = $parent->getParentClass();
        }

        return array_unique($traits);
    }

    /**
     * Convert enum to TypeScript union type.
     *
     * @param class-string $enumClass
     */
    private function convertEnumType(string $enumClass): string
    {
        $reflection = new ReflectionClass($enumClass);
        $cases = $reflection->getMethod('cases')->invoke(null);

        if (!is_array($cases)) {
            return 'any';
        }

        $values = array_map(function($case) {
            // Check if it's a backed enum
            if (is_object($case) && property_exists($case, 'value')) {
                $value = $case->value;

                return is_string($value) ? sprintf("'%s'", $value) : $value;
            }

            if (is_object($case) && property_exists($case, 'name')) {
                return sprintf("'%s'", $case->name);
            }

            return 'any';
        }, $cases);

        return implode(' | ', $values);
    }

    /** Convert union type to TypeScript. */
    private function convertUnionType(ReflectionUnionType $type): string
    {
        $types = [];

        foreach ($type->getTypes() as $namedType) {
            if ($namedType instanceof ReflectionNamedType) {
                $types[] = $this->convertNamedType($namedType);
            } elseif (class_exists('ReflectionIntersectionType') && $namedType instanceof \ReflectionIntersectionType) {
                // For intersection types, just use 'any' for now
                $types[] = 'any';
            }
        }

        return implode(' | ', array_unique($types));
    }
}

